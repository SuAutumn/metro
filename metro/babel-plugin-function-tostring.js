const generate = require("@babel/generator").default;
const template = require("@babel/template").default;

/**
 * Represents a function string.
 */
class FunctionString {
  /**
   * @param {import("@babel/core").NodePath} path
   * @param {import("@babel/core").types} types
   */
  constructor(path, types) {
    this.path = path;
    this.types = types;
  }

  isFunction() {
    const path = this.path;
    return (
      path.isFunctionExpression() ||
      path.isFunctionDeclaration() ||
      path.isArrowFunctionExpression()
    );
  }

  isFunctionInProgram() {
    if (this.path.isFunctionDeclaration()) {
      return this.path.parentPath.isProgram();
    }
    if (
      this.path.isFunctionExpression() ||
      this.path.isArrowFunctionExpression()
    ) {
      // 如果是函数表达式，检查它是否在变量声明中
      return (
        this.path.parentPath.isVariableDeclarator() &&
        this.path.parentPath.parentPath.isVariableDeclaration() &&
        this.path.parentPath.parentPath.parentPath.isProgram()
      );
    }
  }

  isFunctionInObjectExpression() {
    const t = this.types;
    const path = this.path;
    return (
      t.isProperty(path.parent) && t.isObjectExpression(path.parentPath.parent)
    );
  }

  /**
   * 检查函数是否在对象表达式或文件中。
   * @returns {boolean}
   */
  isFunctionInObjectExpressionOrProgram() {
    // 不是目标函数 或者 节点是由插件生成的，直接返回 false
    if (!this.isFunction() || this.path.node._generatedByPlugin) {
      return false;
    }
    return this.isFunctionInObjectExpression() || this.isFunctionInProgram();
  }

  getFunction() {
    const t = this.types;
    const path = this.path;
    if (path.isFunctionDeclaration()) {
      return path;
    }
    if (path.isFunctionExpression()) {
      if (path.node.id) {
        return path;
      } else if (path.parentPath.isVariableDeclarator()) {
        return path.parentPath;
      }
    }
    if (path.isArrowFunctionExpression()) {
      if (path.parentPath.isVariableDeclarator()) {
        return path.parentPath;
      }
      if (path.parentPath.isProperty()) {
        // 如果是箭头函数，检查它是否在对象表达式中
        return path;
      }
    }
    // 立即执行的匿名函数会返回null
    return null;
  }

  generateFunctionStringNode() {
    const t = this.types;
    const toStringFunction = t.functionExpression(
      null,
      [],
      t.blockStatement([
        t.returnStatement(t.stringLiteral(this.path.toString())),
      ])
    );
    // Add a comment to the function to indicate it was generated by the plugin
    toStringFunction._generatedByPlugin = true;
    if (this.isFunctionInProgram()) {
      const f = this.getFunction();
      if (!f) {
        return;
      }
      const name = f.node.id?.name;
      if (!name) {
        return;
      }
      const statement = t.expressionStatement(
        t.assignmentExpression(
          "=",
          t.memberExpression(t.identifier(name), t.identifier("toString")),
          toStringFunction
        )
      );
      this.insertAfter(statement, f);
      return;
    }
    if (this.isFunctionInObjectExpression()) {
      const f = this.getFunction();
      if (!f) {
        return;
      }
      const tmp = template(`(() => {
        const _tmpFunc = FUNCTION;
        _tmpFunc.toString = FUNCTION_STRING;
        return _tmpFunc;
      })()`);
      console.log("f", f.node.id?.name, generate(f.node).code);
      const statement = tmp({
        FUNCTION: f.node,
        FUNCTION_STRING: toStringFunction,
      });
      this.path.replaceWith(statement);
      return;
    }
  }

  /**
   *
   * @param {import("@babel/core").Node} statement
   * @param {import('@babel/core').NodePath} path
   */
  insertAfter(statement, path) {
    const t = this.types;
    if (path.isFunctionDeclaration()) {
      path.insertAfter(statement);
      return;
    }
    if (path.isVariableDeclarator()) {
      const parentPath = path.parentPath;
      if (parentPath.isVariableDeclaration()) {
        parentPath.insertAfter(statement);
        return;
      }
    }
  }
}

/**
 * Babel plugin to add a `toString` method to functions, variables, and class methods.
 *
 * This plugin modifies the AST to append a `toString` method that returns the source code
 * of the function or method it is attached to. It supports function declarations, variable
 * declarators with function expressions or arrow functions, and class methods.
 *
 * @param {import("@babel/core")} babel - The Babel object.
 * @param {import("@babel/core").types} babel.types - Babel types utility for AST manipulation.
 * @returns {import("@babel/core").PluginObj} A Babel visitor object to traverse and transform the AST.
 */
module.exports = function ({ types: t }) {
  return {
    visitor: {
      Function(path) {
        const functionString = new FunctionString(path, t);
        if (functionString.isFunctionInObjectExpressionOrProgram()) {
          functionString.generateFunctionStringNode();
        }
      },
    },
  };
};
